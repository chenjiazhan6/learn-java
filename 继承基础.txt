java继承：
两个类存在明显的is-a关系，这两个类才会有继承，比如manager一定是employees，
所以这两个类存在明显的继承关系，manager能够通过继承employees来编写类。
假设有一个类employees，另外一个类manager通过继承employees，那么语法为
class manager extends employees{
........
}
manager会继承该类的所有内容，包括私有变量和私有方法，不过嘛，拥有和可以操作它是两回事，
虽然私有变量和私有方法存在，但是你却操作不了它，这叫什么呢？空有宝山而不可得。
如果你不相信子类拥有父类的私有变量，可以通过以下方法来测试它。
public class employees {
	private int number = 666;
	public int getNumber(){
	   return number;
	}
}
public class manager extends employees{
	...
}
public class test{
	public static void main(String[] args){
		manager m = new manager();
		System.out.println(m.getNumber());
	}
}
最终也能够证实子类是拥有父类的所有变量和方法的，只是私有变量需要通过父类的public方法来进行访问。
而private方法虽然存在，但是却不能在子类中显式调用，这个的用途应该是辅助方法吧。下面其实还会进行
更加详细的解释，但是还是让我们回到子类构造器问题上来吧。

子类构造器听起来就是来构造子类对象的，那么子类构造器与一般构造器的区别又在哪里呢？
这样说也不太对，因为所有类都有继承Object类，所有的类都是Object的子类。
不过就不顾及那么多了，就随意一点吧。
两者只有一点区别，就是如果父类没有无参构造器的话，必须在子类构造器的第一行显示
调用父类的构造器，记住呀，必须是第一行，不然会报错的。
例子：
假设Manager继承了Employees,super(...)调用的便是Employees的构造器。
public Manger()
{
	super(....);
	.....;
}
如果具有无参构造器的话
public Manger(){
	super();//这一句是可有可无的
	.....
}
因为你不加的话，系统也会自动帮你调用父类的无参构造器，不管你想不想要，一定会帮你加上去的，没毛病。
不过需要注意的是，如果父类中有有参构造器的话，无参构造器是需要自己创建的，系统是不会自动生成一个给你的，
在子类中就必须显示调用父类有参的构造器。

通过这个构造器我们是不是能够更加清楚为什么子类具有所有的变量和方法，你看它都那么贴心得帮你调用
父类构造器了。我们可以猜测子类中有一个看不见父类的引用变量，在子类的构造器的第一行就
通过调用父类构造器对该引用变量进行初始化，而子类在使用父类的方法的时候，可能就是通过这个我们看不到
的引用变量进行调用父类的方法。而自然的，private变量和方法在其他类中是没有办法访问的，这也就很好的解释
子类对象存在这个实例域却不能直接访问它。

说到继承，自然也就离不开多态和动态绑定。

多态其实是父类的引用指向子类的对象，感觉听起来有点玄乎。
其实可以联系到上面，既然我的子类对象里面存在着一个父类的引用，那么我们可不可以这样理解，
这个父类引用表面看起来是指向我的子类对象的，实际上可能是指向了子类对象里面的看不见父类引用，
而此时也就只有父类的方法和变量可以使用，子类新增加的变量和方法都是不能使用了。

但是这个和直接创建父类对象还是有非常大的区别的，这就涉及到了动态绑定。
如果父类的引用指向了子类一个对象，那么该引用只能使用该父类中已经存在的方法，那是不是直接就
调用父类中的方法呢？哈哈，肯定不是这样子，不然的话根本就没有太大用处了。
简单点说，就是从外到里，我们假设父类引用是放在最里面的，假如子类对将要调用的方法已经进行了覆盖，
那么便会直接调用子类的方法。所以这样子才能实现不同的对象进行同样的操作能有不同的结果。
public class Employees{
	private int Salary;
	public int getSalary(){
		return Salary;
	}
}
public class Manger extends Employees{
	public int getSalary(){
		System.out.println(这个是覆盖父类的方法);
		return Salary;
	}
}
public class test{
	public static void main(String[] args){
		Employees e = new Manger();
		int Salary = e.getSalary();
		System.out.println(Salary);
	}
 }
 
毫无疑问，调用的肯定是子类的getSalary方法，因为子类已经对该方法进行了覆盖。
这样子理解吧，父类引用引向子类对象，只能调用父类中已经存在的方法，但是如果子类中有对该方法
进行覆盖，那么就会调用子类中的方法。

其实，虚拟机为每个类创建了一个方法表，子类的方法表存在父类的所有方法，不过如果子类覆盖了
父类的方法，那么该方法会指向子类的代码，对其进行更新。
当父类引用指向子类对象时，虽然只能调用父类的方法，但是方法调用应该还是在子类的方法表进行查询，而不是
在父类的方法表中查询。

但类不想要被别人继承，或者我的某个方法不想被别人所覆盖，那么此时就要用final修饰符了。
public final class employees{
	......
}
当一个类声明为final后，类中的方法也同时变为final，但是却不包括其中的域。

我们的虚拟机的即时编译器能够知道类之间有无继承，是否方法之间存在覆盖，如果方法简短，被频繁调用，
且没有被覆盖，那么即时编译器会对该方法进行内联处理。
虚拟机不再执行正常的方法调用（参数压栈，跳转到方法处执行，再调回，处理栈参数，处理返回值），
而是直接将方法展开，以方法的实际代码替代原来的方法调用。
这样减少了方法调用的开销。当然如果一个方法体本身就很大，这样的优势就小了很多了。















